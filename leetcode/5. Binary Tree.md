# 二叉树（Binary Tree）

## 定义（Definition）

```python3
class TreeNode:
    def __init__(self, value=0, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right
```

- 满二叉树（Full Binary Tree）：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。

  ![img](https://camo.githubusercontent.com/ea1f93d12ef6374d3155504e8dfda96bb7c86325a4e357e61b062a954887bce9/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303830363138353830353537362e706e67)

- 完全二叉树（Complete Binary Tree）：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。

  ![img](https://camo.githubusercontent.com/1018be638b7b2e45151250bb3327673b1dad76b102ac7b18319a213ef9010845/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303932303232313633383930332e706e67)

## 递归（Recursion）

**递归三要素**

- **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
- **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
- **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

## 遍历（Traversal）

### Binary Tree Preorder Traversal (144)

![image-20220511163418999](C:\Users\tomxy\AppData\Roaming\Typora\typora-user-images\image-20220511163418999.png)

```python3
# Recursion
class Solution:
    """
    @params: root:TreeNode
    @return: List[int]
    """
    def preorderTraversal(self, root):
        result = []
        self.traversal(result, root)
        return result
    
    
    """
    @params: result:List[int], root:TreeNode
    @return: None
    """
    def traversal(self, result, root):
        if not root:
            return
        
        result.append(root.val)
        self.traversal(result, root.left)
        self.traversal(result, root.right)
```

- Time: O(n)
- Space: O(n)

```python3
# Iteration
class Solution:
    """
    @params: root:TreeNode
    @return: List[int]
    """
    def preorderTraversal(self, root):
        if not root:
            return []
        
        result = []
        stack = []
        
        stack.append(root)
        
        while stack:
            node = stack.pop()
            result.append(node.val)
            if node.right:
                stack.append(node.right)
            if node.left:
                stack.append(node.left)
                
        return result
```

- Time: O(n)
- Space: O(n)

### Binary Tree Inorder Traversal (94)

![image-20220513030152254](C:\Users\tomxy\AppData\Roaming\Typora\typora-user-images\image-20220513030152254.png)

```python3
# Recursion
class Solution:
    """
    @params: root:TreeNode
    @return: List[int]
    """
    def inorderTraversal(self, root):
        result = []
        self.traversal(result, root)
        return result
    
    
    """
    @params: result:List[int], root:TreeNode
    @return: None
    """
    def traversal(self, result, root):
        if not root:
            return
        
        self.traversal(result, root.left)
        result.append(root.val)
        self.traversal(result, root.right)
```

- Time: O(n)
- Space: O(n)

```python3
# Iteration 1
class Solution:
    """
    @params: root:TreeNode
    @return: List[int]
    """
    def inorderTraversal(self, root):
        if not root:
            return []
        
        result = []
        stack = deque()
        cur = root
        
        while cur or stack:
            if cur:
                stack.append(cur)
                cur = cur.left
            else:
                cur = stack.pop()
                result.append(cur.val)
                cur = cur.right
                
        return result
```

- Time: O(n)
- Space: O(n)

### Binary Tree Postorder Traversal (145)

```python3
# Recursion
class Solution:
    """
    @params: root:TreeNode
    @return: List[int]
    """
    def postorderTraversal(self, root):
        result = []
        self.traversal(result, root)
        return result
    
    
    """
    @params: result:List[int], root:TreeNode
    @return: None
    """
    def traversal(self, result, root):
        if not root:
            return
        
        self.traversal(result, root.left)
        self.traversal(result, root.right)
        result.append(root.val)
```

- Time: O(n)
- Space: O(n)

```python3
# Iteration
class Solution:
    """
    @params: root:TreeNode
    @return: List[int]
    """
    def postorderTraversal(self, root):
        if not root:
            return []
        
        result = []
        stack = []
        
        stack.append(root)
        
        while stack:
            node = stack.pop()
            result.append(node.val)
            if node.left:
                stack.append(node.left)
            if node.right:
                stack.append(node.right)
                
        return result[::-1]
```

- Time: O(n)
- Space: O(n)

### Binary Tree Level Order Traversal (102)

![image-20220517163540299](C:\Users\tomxy\AppData\Roaming\Typora\typora-user-images\image-20220517163540299.png)

```python3
# Iteration
class Solution:
    """
    @params: root:TreeNode
    @return: List[List[int]]
    """
    def levelOrder(self, root):
        if not root:
            return []
        
        result = []
        queue = deque()
        queue.append(root)
        
        while queue:
            size = len(queue)
            tmpList = []
            
            for _ in range(size):
                node = queue.popleft()
                tmpList.append(node.val)
                
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
                    
            result.append(tmpList)
            
        return result
```

- Time: O(n)
- Space: O(logn)

## 属性（Attributes）

### Symmetric Tree (101)

```python3
# Recursion
class Solution:
    """
    @params: root:TreeNode
    @return: bool
    """
    def isSymmetric(self, root):
        if not root:
            return True
        
        return self.compare(root.left, root.right)
    
    
    """
    @params: left:TreeNode, right:TreeNode
    @return: bool
    """
    def compare(self, left, right):
        if not left and not right:
            return True
        if left and not right:
            return False
        if not left and right:
            return False
        if left.val != right.val:
            return False
        
        outside = self.compare(left.left, right.right)
        inside = self.compare(left.right, right.left)
        
        return outside and inside
```

- Time: O(n)
- Space: O(logn) 递归系统占用空间

```python3
# Iteration
class Solution:
    """
    @params: root:TreeNode
    @return: bool
    """
    def isSymmetric(self, root):
        if not root:
            return True
        
        queue = deque()
        queue.append(root.left)
        queue.append(root.right)
        
        while queue:
            leftNode = queue.popleft()
            rightNode = queue.popleft()
            
            if not leftNode and not rightNode:
                continue
            if leftNode and not rightNode:
                return False
            if not leftNode and rightNode:
                return False
            if leftNode.val != rightNode.val:
                return False
            
            queue.append(leftNode.left)
            queue.append(rightNode.right)
            queue.append(leftNode.right)
            queue.append(rightNode.left)
            
        return True
```

- Time: O(n)
- Space: O(logn) 队列占用空间



- 100.相同的树
- 572.另一个树的子树

### Maximum Depth of Binary Tree (104)

```python3
# Recursion
class Solution:
    """
    @params: root:TreeNode
    @return: int
    """
    def maxDepth(self, root):
        return self.getDepth(root)
    
    
    """
    @params: root:TreeNode
    @return: int
    """
    def getDepth(self, root):
        if not root:
            return 0
        
        leftDepth = self.getDepth(root.left)
        rightDepth = self.getDepth(root.right)
        depth = max(leftDepth, rightDepth) + 1
        
        return depth
```

- Time: O(n)
- Space: O(logn) 递归系统占用空间

```python3
# Iteration
class Solution:
    """
    @params: root:TreeNode
    @return: int
    """
    def maxDepth(self, root):
        if not root:
            return 0
        
        queue = deque()
        queue.append(root)
        depth = 0
        
        while queue:
            size = len(queue)
            depth += 1
            for _ in range(size):
                node = queue.popleft()
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
                    
        return depth
```

- Time: O(n)
- Space: O(logn) 队列占用空间



- 104.二叉树的最大深度
- 559.n叉树的最大深度

### Minimum Depth of Binary Tree (111)

![image-20220511003119406](C:\Users\tomxy\AppData\Roaming\Typora\typora-user-images\image-20220511003119406.png)

```python3
# Recursion
class Solution:
    """
    @params: root:TreeNode
    @return: int
    """
    def minDepth(self, root):
        return self.getDepth(root)
    
    
    """
    @params: root:TreeNode
    @return: int
    """
    def getDepth(self, root):
        if not root:
            return 0
        
        leftDepth = self.getDepth(root.left)
        rightDepth = self.getDepth(root.right)
        
        if root.left and not root.right:
            return 1 + leftDepth
        
        if not root.left and root.right:
            return 1 + rightDepth
        
        return 1 + min(leftDepth, rightDepth)
```

- Time: O(n)
- Space: O(logn) 递归系统占用空间

```python3
# Iteration
class Solution:
    """
    @params: root:TreeNode
    @return: int
    """
    def minDepth(self, root):
        if not root:
            return 0
        
        minDepth = 0
        queue = deque()
        queue.append(root)
        
        while queue:
            size = len(queue)
            minDepth += 1
            for _ in range(size):
                node = queue.popleft()
                if not node.left and not node.right:
                    return minDepth
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
                    
        return minDepth
```

- Time: O(n)
- Space: O(logn) 队列占用空间

### Count Complete Tree Nodes (222)

![image-20220511013639316](C:\Users\tomxy\AppData\Roaming\Typora\typora-user-images\image-20220511013639316.png)

```python3
# Recursion
class Solution:
    """
    @params: root:TreeNode
    @return: int
    """
    def countNodes(self, root):
        return self.getNum(root)
    
    
    """
    @params: root:TreeNode
    @return: int
    """
    def getNum(self, root):
        if not root:
            return 0
        
        leftNum = self.getNum(root.left)
        rightNum = self.getNum(root.right)
        
        return leftNum + rightNum + 1
```

- Time: O(n)
- Space: O(logn) 递归系统占用空间

```python3
# Iteration
class Solution:
    """
    @params: root:TreeNode
    @return: int
    """
    def countNodes(self, root):
        if not root:
            return 0
        
        result = 0
        queue = deque()
        queue.append(root)
        
        while queue:
            size = len(queue)
            for _ in range(size):
                node = queue.popleft()
                result += 1
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
                    
        return result
```

- Time: O(n)
- Space: O(logn) 队列占用空间

```python3
# Recursion
class Solution:
    """
    @params: root:TreeNode
    @return: int
    """
    def countNodes(self, root):
        return self.getNum(root)
    
    
    """
    @params: root:TreeNode
    @return: int
    """
    def getNum(self, root):
        if not root:
            return 0
        
        left, right = root.left, root.right
        leftHeight, rightHeight = 0, 0
        
        while left:
            left = left.left
            leftHeight += 1
            
        while right:
            right = right.right
            rightHeight += 1
            
        if leftHeight == rightHeight:
            return 2 ** (leftHeight + 1) - 1
        
        return self.getNum(root.left) + self.getNum(root.right) + 1
```

- Time: O(logn * logn)
- Space: O(logn)

### Balanced Binary Tree (110)

![image-20220511153130159](C:\Users\tomxy\AppData\Roaming\Typora\typora-user-images\image-20220511153130159.png)

```python3
# Recursion
class Solution:
    """
    @params: root:TreeNode
    @return: bool
    """
    def isBalanced(self, root):
        if self.getHeight(root) == -1:
            return False
        else:
            return True
        
        
    """
    @params: root:TreeNode
    @return: bool
    """
    def getHeight(self, root):
        if not root:
            return 0
        
        leftHeight = self.getHeight(root.left)
        if leftHeight == -1:
            return -1
        
        rightHeight = self.getHeight(root.right)
        if rightHeight == -1:
            return -1
        
        if abs(leftHeight - rightHeight) > 1:
            return -1
        
        return max(leftHeight, rightHeight) + 1
```

- Time: O(n)
- Space: O(logn) 递归系统占用空间

### Binary Tree Paths (257)

![image-20220511165156168](C:\Users\tomxy\AppData\Roaming\Typora\typora-user-images\image-20220511165156168.png)

```python3
# Recursion
class Solution:
    """
    @params: root:TreeNode
    @return: List[str]
    """
    def binaryTreePaths(self, root):
        result = deque()
        
        if not root:
            return result
        
        path = deque()
        
        self.traversal(root, path, result)
        
        return result
    
    
    """
    @params: root:TreeNode, path:List[int], result:List[str]
    @return: None
    """
    def traversal(self, root, path, result):
        path.append(root.val)
        
        if not root.left and not root.right:
            strPath = ''
            for i in range(len(path) - 1):
                strPath += str(path[i]) + '->'
            strPath += str(path[-1])
            result.append(strPath)
            return
        
        if root.left:
            self.traversal(root.left, path, result)
            path.pop()
            
        if root.right:
            self.traversal(root.right, path, result)
            path.pop()
```

- Time: O(n)
- Space: O(logn) 递归系统占用空间

```python3
# Iteration
class Solution:
    """
    @params: root:TreeNode
    @return: List[str]
    """
    def binaryTreePaths(self, root):
        result = []
        if not root:
            return result
        nodeStack, pathStack = deque(), deque()
        nodeStack.append(root)
        pathStack.append(str(root.val))
        
        while nodeStack:
            node = nodeStack.pop()
            path = pathStack.pop()
            if not node.left and not node.right:
                result.append(path)
            if node.right:
                nodeStack.append(node.right)
                pathStack.append(path + '->' + str(node.right.val))
            if node.left:
                nodeStack.append(node.left)
                pathStack.append(path + '->' + str(node.left.val))
                
        return result
```

- Time: O(n)
- Space: O(logn) 队列占用空间

## 修改（Modify）

### Invert Binary Tree (226)

```python3
# Preorder Recursion
class Solution:
    """
    @params: root:TreeNode
    @return: TreeNode
    """
    def invertTree(self, root):
        if not root:
            return root
        
        root.left, root.right = root.right, root.left
        self.invertTree(root.left)
        self.invertTree(root.right)
        
        return root
```

- Time: O(n)
- Space: O(logn) 递归系统占用空间

```python3
# Preorder Iteration
class Solution:
    """
    @params: root:TreeNode
    @return: TreeNode
    """
    def invertTree(self, root):
        if not root:
            return root
        
        stack = deque()
        stack.append(root)
        
        while stack:
            node = stack.pop()
            node.left, node.right = node.right, node.left
            if node.left:
                stack.append(node.left)
            if node.right:
                stack.append(node.right)
                
        return root
```

- Time: O(n)
- Space: O(logn) 队列占用空间

```python3
# Levelorder Iteration
class Solution:
    """
    @params: root:TreeNode
    @return: TreeNode
    """
    def invertTree(self, root):
        if not root:
            return root
        
        queue = deque()
        queue.append(root)
        
        while queue:
            size = len(queue)
            for _ in range(size):
                node = queue.popleft()
                node.left, node.right = node.right, node.left
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
                    
        return root
```

- Time: O(n)
- Space: O(logn) 队列占用空间

### Construct Binary Tree from Inorder and Postorder Traversal (106)

![image-20220511210541303](C:\Users\tomxy\AppData\Roaming\Typora\typora-user-images\image-20220511210541303.png)

```python3
class Solution:
    """
    @params: inorder:List[int], postorder:List[int]
    @return: TreeNode
    """
    def buildTree(self, inorder, postorder):
        if not inorder or not postorder:
            return None
        if len(inorder) == 0 or len(postorder) == 0 or len(inorder) != len(postorder):
            return None
        return self.traversal(inorder, 0, len(inorder), postorder, 0, len(postorder))
    
    
    """
    @params: inorder:List[int], inStart:int, inEnd:int, postorder:List[int], postStart:int, postEnd:int
    @return: TreeNode
    """
    def traversal(self, inorder, inStart, inEnd, postorder, postStart, postEnd):
        if postStart == postEnd:
            return None
        
        root = TreeNode(postorder[postEnd - 1])
        
        if postEnd - postStart == 1:
            return root
        
        delimiterIndex = inorder.index(root.val)
                
       	leftInStart, leftInEnd = inStart, delimiterIndex
        rightInStart, rightInEnd = delimiterIndex + 1, inEnd
        
        leftPostStart, leftPostEnd = postStart, postStart + delimiterIndex - inStart
        rightPostStart, rightPostEnd = postStart + delimiterIndex - inStart, postEnd - 1
        
        root.left = self.traversal(inorder, leftInStart, leftInEnd, postorder, leftPostStart, leftPostEnd)
        root.right = self.traversal(inorder, rightInStart, rightInEnd, postorder, rightPostStart, rightPostEnd)
        
        return root
```

- Time: 
- Space: 

### Construct Binary Tree from Preorder and Inorder Traversal (105)

![image-20220511211947616](C:\Users\tomxy\AppData\Roaming\Typora\typora-user-images\image-20220511211947616.png)

```python3
class Solution:
    """
    @params: preorder:List[int], inorder:List[int]
    @return: TreeNode
    """
    def buildTree(self, preorder, inorder):
        if not preorder or not inorder:
            return None
        if len(preorder) == 0 or len(inorder) == 0 or len(preorder) != len(inorder):
            return None
        return self.traversal(preorder, 0, len(preorder), inorder, 0, len(inorder))
    
    
    """
    @params: preorder:List[int], preStart:int, preEnd:int, inorder:List[int], inStart:int, inEnd:int
    @return: TreeNode
    """
    def traversal(self, preorder, preStart, preEnd, inorder, inStart, inEnd):
        if preStart == preEnd:
            return None
        
        root = TreeNode(preorder[preStart])
        
        if preEnd - preStart == 1:
            return root
        
        delimiterIndex = inorder.index(root.val)
                
        leftInStart, leftInEnd = inStart, delimiterIndex
        rightInStart, rightInEnd = delimiterIndex + 1, inEnd
        
        leftPreStart, leftPreEnd = preStart + 1, preStart + 1 + delimiterIndex - inStart
        rightPreStart, rightPreEnd = preStart + 1 + delimiterIndex - inStart, preEnd
        
        root.left = self.traversal(preorder, leftPreStart, leftPreEnd, inorder, leftInStart, leftInEnd)
        root.right = self.traversal(preorder, rightPreStart, rightPreEnd, inorder, rightInStart, rightInEnd)
        
        return root
```

- Time: 
- Space: 

### Maximum Binary Tree (654)

![image-20220511214656851](C:\Users\tomxy\AppData\Roaming\Typora\typora-user-images\image-20220511214656851.png)

```python3
class Solution:
    """
    @params: nums:List[int]
    @return: TreeNode
    """
    def constructMaximumBinaryTree(self, nums):
        if not nums or len(nums) == 0:
            return None
        return self.traversal(nums, 0, len(nums))
    
    
    """
    @params: nums:List[int], start:int, end:int
    @return: TreeNode
    """
    def traversal(self, nums, start, end):
        if start >= end:
            return None
        
        maxValueIndex = start
        for i in range(start, end):
            if nums[i] > nums[maxValueIndex]:
                maxValueIndex = i
                
        root = TreeNode(nums[maxValueIndex])
        
        if end - start == 1:
            return root
        
        leftStart, leftEnd = start, maxValueIndex
        rightStart, rightEnd = maxValueIndex + 1, end
        
        root.left = self.traversal(nums, leftStart, leftEnd)
        root.right = self.traversal(nums, rightStart, rightEnd)
        
        return root
```

- Time: 
- Space: 

### Merge Two Binary Trees (617)

![image-20220512170359803](C:\Users\tomxy\AppData\Roaming\Typora\typora-user-images\image-20220512170359803.png)

```python3
# Recursion
class Solution:
    """
    @params: root1:TreeNode, root2:TreeNode
    @return: TreeNode
    """
    def mergeTrees(self, root1, root2):
        if not root1:
            return root2
        if not root2:
            return root1
        
        root1.val += root2.val
        root1.left = self.mergeTrees(root1.left, root2.left)
        root1.right = self.mergeTrees(root1.right, root2.right)
        
        return root1
```

- Time: O(n)
- Space: O(logn) 递归系统占用空间

```python3
# Iteration
class Solution:
    """
    @params: root1:TreeNode, root2:TreeNode
    @return: TreeNode
    """
    def mergeTrees(self, root1, root2):
        if not root1:
            return root2
        if not root2:
            return root1
        
        queue = deque()
        queue.append(root1)
        queue.append(root2)
        
        while queue:
            node1 = queue.popleft()
            node2 = queue.popleft()
            node1.val += node2.val
            
            if node1.left and node2.left:
                queue.append(node1.left)
                queue.append(node2.left)
                
            if node1.right and node2.right:
                queue.append(node1.right)
                queue.append(node2.right)
                
            if not node1.left and node2.left:
                node1.left = node2.left
                
            if not node1.right and node2.right:
                node1.right = node2.right
                
        return root1
```

- Time: O(n)
- Space: O(logn) 队列占用空间

## 公共祖先（Common Ancestor）

### Lowest Common Ancestor of a Binary Tree (236)

![image-20220515152622885](C:\Users\tomxy\AppData\Roaming\Typora\typora-user-images\image-20220515152622885.png)

```python3
class Solution:
    """
    @params: root:TreeNode, p:TreeNode, q:TreeNode
    @return: TreeNode
    """
    def lowestCommonAncestor(self, root, p, q):
        if not root or root == p or root == q:
            return root
        
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        
        if left and right:
            return root
        elif not left and right:
            return right
        elif left and not right:
            return left
        else:
            return None
```

- Time: O(n)
- Space: O(logn)

- 

# 二叉搜索树（Binary Search Tree）

## 定义（Definition）

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值。
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值。
- 它的左、右子树也分别为二叉排序树。

![img](https://camo.githubusercontent.com/baf80c89d697a6f70da4e513bcfbe7103f83e8f369ee3f46bda4e1482a12ba8e/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303830363139303330343639332e706e67)

## 遍历（Traversal）

### Binary Search Tree Iterator (173)

![image-20220517170521418](C:\Users\tomxy\AppData\Roaming\Typora\typora-user-images\image-20220517170521418.png)

```python3
class BSTIterator:
    """
    @params: root:TreeNode
    @return: None
    """
    def __init__(self, root):
        self.stack = deque()
        self.appendLeftNodes(root)
    
    
    """
    @params: None
    @return: int
    """
    def next(self):
        node = self.stack.pop()
        if node.right:
            self.appendLeftNodes(node.right)
            
        return node.val
    
    
    """
    @params: None
    @return: bool
    """
    def hasNext(self):
        return len(self.stack) > 0
    
    
    """
    @params: root:TreeNode
    @return: None
    """
    def appendLeftNodes(self, root):
        while root:
            self.stack.append(root)
            root = root.left
```

## 属性（Attributes）

### Search in a Binary Search Tree (700)

![image-20220513015822135](C:\Users\tomxy\AppData\Roaming\Typora\typora-user-images\image-20220513015822135.png)

```python3
# Recursion
class Solution:
    """
    @params: root:TreeNode, val:int
    @return: TreeNode
    """
    def searchBST(self, root, val):
        if not root or root.val == val:
            return root
        
        if root.val < val:
            return self.searchBST(root.right, val)
        
        if root.val > val:
            return self.searchBST(root.left, val)
```

- Time: O(logn)
- Space: O(logn) 递归系统占用空间

```python3
# Iteration
class Solution:
    """
    @params: root:TreeNode, val:int
    @return: TreeNode
    """
    def searchBST(self, root, val):
        while root:
            if root.val < val:
                root = root.right
            elif root.val > val:
                root = root.left
            else:
                return root
            
        return root
```

- Time: O(logn)
- Space: O(1)

### Validate Binary Search Tree (98)

![image-20220513031106857](C:\Users\tomxy\AppData\Roaming\Typora\typora-user-images\image-20220513031106857.png)

```python3
# Recursion 1
class Solution:
    """
    @params: root:TreeNode
    @return: bool
    """
    def isValidBST(self, root):
        nums = []
        self.inorderTraversal(root, nums)
        for i in range(1, len(nums)):
            if nums[i] <= nums[i - 1]:
                return False
            
        return True
        
        
    """
    @params: root:TreeNode, nums:List[int]
    @return: bool
    """
    def inorderTraversal(self, root, nums):
        if not root:
            return
        
        self.inorderTraversal(root.left, nums)
        
        nums.append(root.val)
        
        self.inorderTraversal(root.right, nums)
```

- Time: O(n)
- Space: O(n)

```python3
# Recursion 2
class Solution:
    pre = None
    """
    @params: root:TreeNode
    @return: bool
    """
    def isValidBST(self, root):
        if not root:
            return True
        
        left = self.isValidBST(root.left)
        
        if self.pre and self.pre.val >= root.val:
            return False
        self.pre = root
        
        right = self.isValidBST(root.right)
        
        return left and right
```

- Time: O(n)
- Space: O(logn) 递归系统占用空间

```python3
# Iteration
class Solution:
    """
    @params: root:TreeNode
    @return: bool
    """
    def isValidBST(self, root):
        if not root:
            return True
        
        stack = deque()
        pre, cur = None, root
        
        while cur or stack:
            if cur:
                stack.append(cur)
                cur = cur.left
            else:
                cur = stack.pop()
                if pre and pre.val >= cur.val:
                    return False
                pre = cur
                cur = cur.right
                
        return True
```

- Time: O(n)
- Space: O(logn) 栈占用空间

### Minimum Absolute Difference in BST (530)

![image-20220514034128594](C:\Users\tomxy\AppData\Roaming\Typora\typora-user-images\image-20220514034128594.png)

```python3
# Recursion
class Solution:
    result = float("inf") # float("inf")表示正无穷大，float("-inf")表示负无穷大
    pre = None
    """
    @params: root:TreeNode
    @return: int
    """
    def getMinimumDifference(self, root):
        self.inorderTraversal(root)
        return self.result
    
    
    """
    @params: root:TreeNode
    @return: None
    """
    def inorderTraversal(self, root):
        if not root:
            return
        
        self.inorderTraversal(root.left)
        
        if self.pre:
            self.result = min(self.result, root.val - self.pre.val)
        self.pre = root
            
        self.inorderTraversal(root.right)
```

- Time: O(n)
- Space: O(logn) 递归系统占用空间

```python3
# Iteration
class Solution:
    """
    @params: root:TreeNode
    @return: int
    """
    def getMinimumDifference(self, root):
        if not root:
            return -1
        
        result = float("inf")
        stack = deque()
        pre, cur = None, root
        
        while cur or stack:
            if cur:
                stack.append(cur)
                cur = cur.left
            else:
                cur = stack.pop()
                if pre:
                    result = min(result, cur.val - pre.val)
                pre = cur
                cur = cur.right
                
        return result
```

- Time: O(n)
- Space: O(logn) 栈占用空间

### Find Mode in Binary Search Tree (501)

![image-20220514201152550](C:\Users\tomxy\AppData\Roaming\Typora\typora-user-images\image-20220514201152550.png)

```python3
# 普通二叉树解法
class Solution:
    def __init__(self):
        self.count = {}
        
        
    """
    @params: root:TreeNode
    @return: List[int]
    """
    def findMode(self, root):
        
        result = []
        
        self.traversal(root)
        
        maxCount = 0
        
        for key, value in self.count.items():
            if value == maxCount:
                result.append(key)
            if value > maxCount:
                maxCount = value
                result.clear()
                result.append(key)
                
        return result
        
        
    """
    @params: root:TreeNode
    @return: None
    """
    def traversal(self, root):
        if not root:
            return
        
        self.traversal(root.left)
        self.count[root.val] = self.count.get(root.val, 0) + 1
        self.traversal(root.right)
        
        return
```

- Time: O(n)
- Space: O(n)

```python3
# Recursion
class Solution:
    def __init__(self):
        self.pre = None
        self.count = 0
        self.maxCount = 0
        self.result = []
        
        
    """
    @params: root:TreeNode
    @return: List[int]
    """
    def findMode(self, root):
        self.traversal(root)
        return self.result
    
    
    """
    @params: root:TreeNode
    @return: None
    """
    def traversal(self, root):
        if not root:
            return
        
        self.traversal(root.left)
        
        if not self.pre:
            self.count = 1
        elif self.pre.val == root.val:
            self.count += 1
        else:
            self.count = 1
            
        self.pre = root
        
        if self.count == self.maxCount:
            self.result.append(root.val)
        
        if self.count > self.maxCount:
            self.maxCount = self.count
            self.result.clear()
            self.result.append(root.val)
            
        self.traversal(root.right)
        
        return
```

- Time: O(n)
- Space: O(logn) 递归系统占用空间

```python3
# Iteration
class Solution:
    """
    @params: root:TreeNode
    @return: List[int]
    """
    def findMode(self, root):
        if not root:
            return []
        
        result = []
        stack = deque()
        pre, cur = None, root
        count, maxCount = 0, 0
        
        while cur or stack:
            if cur:
                stack.append(cur)
                cur = cur.left
            else:
                cur = stack.pop()
                if not pre:
                    count = 1
                elif pre.val == cur.val:
                    count += 1
                else:
                    count = 1
                    
                pre = cur
                
                if count == maxCount:
                    result.append(cur.val)
                    
                if count > maxCount:
                    maxCount = count
                    result.clear()
                    result.append(cur.val)
                    
                cur = cur.right
                
        return result
```

- Time: O(n)
- Space: O(logn) 栈占用空间

### Convert BST to Greater Tree (538)

![image-20220516204810748](C:\Users\tomxy\AppData\Roaming\Typora\typora-user-images\image-20220516204810748.png)

```python3
# Recursion
class Solution:
    def __init__(self):
        self.sum = 0
    
    
    """
    @params: root:TreeNode
    @return: TreeNode
    """
    def convertBST(self, root):
        if not root:
            return root
        
        self.convertBST(root.right)
        
        self.sum += root.val
        root.val = self.sum
        
        self.convertBST(root.left)
        
        return root
```

- Time: O(n)
- Space: O(logn)

```python3
# Iteration
class Solution:
    """
    @params: root:TreeNode
    @return: TreeNode
    """
    def convertBST(self, root):
        if not root:
            return root
        
        stack = deque()
        numSum = 0
        cur = root
        
        while cur or stack:
            if cur:
                stack.append(cur)
                cur = cur.right
            else:
                cur = stack.pop()
                numSum += cur.val
                cur.val = numSum
                cur = cur.left
                
        return root
```

- Time: O(n)
- Space: O(logn)

## 修改（Modify）

### Insert into a Binary Search Tree (701)

![image-20220515212707962](C:\Users\tomxy\AppData\Roaming\Typora\typora-user-images\image-20220515212707962.png)

```python3
# Recursion
class Solution:
    """
    @params: root:TreeNode, val:int
    @return: TreeNode
    """
    def insertIntoBST(self, root, val):
        if not root:
            node = TreeNode(val)
            return node
        
        if root.val > val:
            root.left = self.insertIntoBST(root.left, val)
            
        if root.val < val:
            root.right = self.insertIntoBST(root.right, val)
            
        return root
```

- Time: O(logn)
- Space: O(logn)

```python3
# Iteration
class Solution:
    """
    @params: root:TreeNode, val:int
    @return: TreeNode
    """
    def insertIntoBST(self, root, val):
        if not root:
            return TreeNode(val)
        
        pre, cur = root, root
        
        while cur:
            pre = cur
            if cur.val > val:
                cur = cur.left
            else:
                cur = cur.right
                
        if pre.val > val:
            pre.left = TreeNode(val)
        else:
            pre.right = TreeNode(val)
            
        return root
```

- Time: O(logn)
- Space: O(1)

### Delete Node in a Binary Search Tree (450)

![image-20220515222631951](C:\Users\tomxy\AppData\Roaming\Typora\typora-user-images\image-20220515222631951.png)

```python3
# Recursion
class Solution:
    """
    @params: root:TreeNode, key:int
    @return: TreeNode
    """
    def deleteNode(self, root, key):
        if not root:
            return root
        if root.val == key:
            if not root.left and not root.right:
                return None
            if root.left and not root.right:
                return root.left
            if not root.left and root.right:
                return root.right
            if root.left and root.right:
                cur = root.right
                while cur.left:
                    cur = cur.left
                cur.left = root.left
                return root.right
            
        if root.val > key:
            root.left = self.deleteNode(root.left, key)
        if root.val < key:
            root.right = self.deleteNode(root.right, key)
            
        return root
```

- Time: O(logn)
- Space: O(logn)

```python3
# Iteration
class Solution:
    """
    @params: root:TreeNode, key:int
    @return: TreeNode
    """
    def deleteNode(self, root, key):
        pre, cur = None, root
        
        while cur:
            if cur.val == key:
                break
                
            pre = cur
            
            if cur.val > key:
                cur = cur.left
            else:
                cur = cur.right
                
        if not cur:
            return root
                
        if not pre:
            return self.delete(cur)
        
        if pre.val > cur.val:
            pre.left = self.delete(cur)
        if pre.val < cur.val:
            pre.right = self.delete(cur)
            
        return root
    
    
    """
    @params: cur:TreeNode
    @return: TreeNode
    """
    def delete(self, cur):
        if not cur.left and not cur.right:
            return None
        if cur.left and not cur.right:
            return cur.left
        if not cur.left and cur.right:
            return cur.right
        if cur.left and cur.right:
            tmp = cur.right
            while tmp.left:
                tmp = tmp.left
            tmp.left = cur.left
            return cur.right
```

- Time: O(logn)
- Space: O(1)

### Trim a Binary Search Tree (669)

![image-20220516195317781](C:\Users\tomxy\AppData\Roaming\Typora\typora-user-images\image-20220516195317781.png)

```python3
# Recursion
class Solution:
    """
    @params: root:TreeNode, low:int, high:int
    @return: TreeNode
    """
    def trimBST(self, root, low, high):
        if not root:
            return root
        
        if root.val < low:
            right = self.trimBST(root.right, low, high)
            return right
        
        if root.val > high:
            left = self.trimBST(root.left, low, high)
            return left
        
        root.left = self.trimBST(root.left, low, high)
        root.right = self.trimBST(root.right, low, high)
        
        return root
```

- Time: O(n)
- Space: O(logn)

```python3
# Iteration
class Solution:
    """
    @params: root:TreeNode, low:int, high:int
    @return: TreeNode
    """
    def trimBST(self, root, low, high):
        if not root:
            return root
        
        while root:
            if root.val < low:
                root = root.right
            elif root.val > high:
                root = root.left
            else:
                break
                
        cur = root
        while cur:
            while cur.left and cur.left.val < low:
                cur.left = cur.left.right
            cur = cur.left
            
        cur = root
        while cur:
            while cur.right and cur.right.val > high:
                cur.right = cur.right.left
            cur = cur.right
            
        return root
```

- Time: O(n)
- Space: O(1)

### Convert Sorted Array to Binary Search Tree (108)

![image-20220516202705502](C:\Users\tomxy\AppData\Roaming\Typora\typora-user-images\image-20220516202705502.png)

```python3
# Recursion
class Solution:
    """
    @params: nums:List[int]
    @return: TreeNode
    """
    def sortedArrayToBST(self, nums):
        return self.construct(nums, 0, len(nums) - 1)
    
    
    """
    @params: nums:List[int], left:int, right:int
    @return: TreeNode
    """
    def construct(self, nums, left, right):
        if left > right:
            return None
        
        mid = left + (right - left) // 2
        
        root = TreeNode(nums[mid])
        root.left = self.construct(nums, left, mid - 1)
        root.right = self.construct(nums, mid + 1, right)
        
        return root
```

- Time: O(n)
- Space: O(logn)

```python3
# Iteration
class Solution:
    """
    @params: nums:List[int]
    @return: TreeNode
    """
    def sortedArrayToBST(self, nums):
        if not nums or len(nums) == 0:
            return None
        
        root = TreeNode(0)
        queue = deque()
        queue.append((root, 0, len(nums) - 1))
        
        while queue:
            node, left, right = queue.pop()
            mid = left + (right - left) // 2
            node.val = nums[mid]
            if left <= mid - 1:
                node.left = TreeNode(0)
                queue.append((node.left, left, mid - 1))
            if right >= mid + 1:
                node.right = TreeNode(0)
                queue.append((node.right, mid + 1, right))
                
        return root
```

- Time: O(n)
- Space: O(1)

## 公共祖先（Common Ancestor）

### Lowest Common Ancestor of a Binary Search Tree (235)

![image-20220515183750759](C:\Users\tomxy\AppData\Roaming\Typora\typora-user-images\image-20220515183750759.png)

```python3
# Recursion
class Solution:
    """
    @params: root:TreeNode, p:TreeNode, q:TreeNode
    @return: TreeNode
    """
    def lowestCommonAncestor(self, root, p, q):
        if not root:
            return root
        
        if root.val > p.val and root.val > q.val:
            left = self.lowestCommonAncestor(root.left, p, q)
            if left:
                return left
            
        if root.val < p.val and root.val < q.val:
            right = self.lowestCommonAncestor(root.right, p, q)
            if right:
                return right
            
        return root
```

- Time: O(n)
- Space: O(logn)

```python3
# Iteration
class Solution:
    """
    @params: root:TreeNode, p:TreeNode, q:TreeNode
    @return: TreeNode
    """
    def lowestCommonAncestor(self, root, p, q):
        while root:
            if root.val > p.val and root.val > q.val:
                root = root.left
            elif root.val < p.val and root.val < q.val:
                root = root.right
            else:
                return root
            
        return root
```

- Time: O(n)
- Space: O(1)

# 二叉平衡搜索树（Balanced Binary Search Tree）

## 定义（Definition）

- 又被称为AVL（Adelson-Velsky and Landis）树。
- 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1。
- 左右两个子树都是一棵平衡二叉树。

![img](https://camo.githubusercontent.com/43cdb4219b8917c8af61a234d92a01b601ee224efd08255d4f6c97c1d4c67c57/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303830363139303531313936372e706e67)